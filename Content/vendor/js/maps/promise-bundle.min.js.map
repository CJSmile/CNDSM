{"version":3,"sources":["promise.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../promise-bundle.min.js","sourcesContent":["(function() {\r\n\r\n  'use strict';\r\n\r\n  var Promise = function() {\r\n    this.thenTargets = [];\r\n    this.pending = true;\r\n  };\r\n\r\n  var isPromise = function(promise) {\r\n    return promise && promise instanceof Promise;\r\n  }\r\n\r\n  var isPseudoPromise = function(promise) {\r\n    return promise && typeof promise.then == 'function';\r\n  }\r\n\r\n  Promise.prototype.resolve = function(promise, value) {\r\n    if (promise === value) {\r\n      throw new TypeError('resolve: arguments cannot be the same object')\r\n    }\r\n    if (promise === value) {\r\n      throw new TypeError('resolve: arguments cannot be the same object')\r\n    }\r\n    if (isPromise(value) || isPseudoPromise(value)) {\r\n      value.then(promise.fulfil.bind(promise), promise.reject.bind(promise))\r\n    } else {\r\n      promise.fulfil(value);\r\n    }\r\n  };\r\n\r\n  Promise.prototype.handleThenTargets = function() {\r\n    var callbackResult;\r\n    var callback;\r\n    var value;\r\n    var i;\r\n\r\n    for (i=0;i<this.thenTargets.length;++i) {\r\n      if (this.fulfilled) {\r\n        callback = this.thenTargets[i].onFulfilled;\r\n        value = this.value;\r\n      }\r\n      if (this.rejected) {\r\n        callback = this.thenTargets[i].onRejected;\r\n        value = this.reason;\r\n      }\r\n      try {\r\n        if (callback && typeof callback === 'function') {\r\n          callbackResult = callback.apply(undefined, value);\r\n        } else {\r\n          callbackResult = this;\r\n        }\r\n        this.resolve(this.thenTargets[i], callbackResult);\r\n      }\r\n      catch(err) {\r\n        this.thenTargets[i].reject(err);\r\n      }\r\n    }\r\n    this.thenTargets = [];\r\n  };\r\n\r\n  Promise.prototype.handleThen = function() {\r\n    if (!this.pending) {\r\n      this.handleThenTargets();\r\n    }\r\n  };\r\n\r\n  Promise.prototype.then = function(onFulfilled, onRejected) {\r\n    var thenResult = new Promise();\r\n    // The execution of then is asynchronous so we need to have this info available later.\r\n    thenResult.onFulfilled = onFulfilled;\r\n    thenResult.onRejected = onRejected;\r\n    this.thenTargets.push(thenResult);\r\n    setTimeout(this.handleThen.bind(this),0);\r\n    return thenResult;\r\n  };\r\n\r\n  Promise.prototype.fulfil = function() {\r\n    var i;\r\n    var linkedPromise;\r\n    if (this.rejected) {\r\n      return;\r\n    }\r\n    this.fulfilled = true;\r\n    this.pending = false;\r\n    this.value = arguments;\r\n\r\n    this.handleThenTargets();\r\n  };\r\n\r\n  Promise.prototype.reject = function() {\r\n    var i;\r\n    var linkedPromise;\r\n    if (this.fulfilled) {\r\n      return;\r\n    }\r\n    this.reason = arguments;\r\n    this.rejected = true;\r\n    this.pending = false;\r\n    this.handleThenTargets();\r\n  }\r\n\r\n  this.Promise = Promise;\r\n\r\n}).call(this);"]}